/**
 * BlocVibe PositionCalculator v3.0
 * ==================================
 * نظام حساب المواضع الذكية للعناصر
 * يحسب أفضل مواضع للعناصر مع مراعاة Flexbox، التخطيط، والعلاقات المكانية
 * 
 * الميزات الأساسية:
 * - حساب مواضع relative للعناصر
 * - إدارة Flexbox layouts
 * - حساب insertion points ذكية
 * - تحسين ترتيب العناصر
 * - دعم responsive positioning
 */

(function() {
    'use strict';
    
    // ==================== ENUMS & CONSTANTS ====================
    
    /**
     * أنواع التخطيط المدعومة
     */
    const LayoutType = Object.freeze({
        BLOCK: 'block',           // تخطيط block عادي
        FLEX_ROW: 'flex-row',     // flexbox horizontal
        FLEX_COLUMN: 'flex-column', // flexbox vertical
        GRID: 'grid',             // CSS Grid (للمستقبل)
        ABSOLUTE: 'absolute'      // موضع مطلق
    });
    
    /**
     * اتجاهات Positioning
     */
    const PositionDirection = Object.freeze({
        ABOVE: 'above',
        BELOW: 'below',
        LEFT: 'left',
        RIGHT: 'right',
        INSIDE: 'inside',
        REPLACE: 'replace'
    });
    
    /**
     * استراتيجيات الحساب
     */
    const CalculationStrategy = Object.freeze({
        OPTIMAL: 'optimal',         // أفضل موضع ممكن
        PRESERVE_LAYOUT: 'preserve-layout', // حفظ التخطيط الحالي
        MINIMIZE_MOVEMENT: 'minimize-movement', // تقليل الحركة
        VISUAL_BALANCE: 'visual-balance' // توازن بصري
    });
    
    // ==================== CLASS DEFINITION ====================
    
    class PositionCalculator {
        constructor() {\n            this.layoutCache = new Map();        // Cache للتخطيطات\n            this.measurementCache = new Map();   // Cache للقياسات\n            this.cacheTimeout = 5000;            // 5 ثوانٍ\n            \n            // إعدادات الحساب\n            this.settings = {\n                minSpacing: 8,                    // أقل مسافة بين العناصر\n                snapThreshold: 15,                // عتبة المحاذاة\n                flexGapDefault: 10,               // المسافة الافتراضية في flex\n                considerVisualWeight: true,       // مراعاة الوزن البصري\n                respectAspectRatio: true          // احترام نسبة العرض للارتفاع\n            };\n            \n            this.init();\n        }\n        \n        // ==================== INITIALIZATION ====================\n        \n        init() {\n            console.log('[PositionCalculator] 📐 Initializing Position Calculation System...');\n            this.setupPerformanceOptimizations();\n            console.log('[PositionCalculator] ✅ Position calculator ready');\n        }\n        \n        setupPerformanceOptimizations() {\n            // تنظيف Cache دورياً\n            setInterval(() => {\n                this.cleanupCache();\n            }, this.cacheTimeout);\n            \n            // Intersection Observer لمراقبة العناصر المرئية\n            this.visibilityObserver = new IntersectionObserver((entries) => {\n                entries.forEach(entry => {\n                    const elementId = entry.target.id || entry.target.dataset.blocId;\n                    if (elementId) {\n                        this.layoutCache.set(`visibility-${elementId}`, entry.isIntersecting);\n                    }\n                });\n            });\n        }\n        \n        // ==================== CORE CALCULATION METHODS ====================\n        \n        /**\n         * حساب أفضل موضع لعنصر مسحوب\n         */\n        calculateOptimalPosition(draggedElement, targetInfo, strategy = CalculationStrategy.OPTIMAL) {\n            const startTime = performance.now();\n            \n            console.log(`[PositionCalculator] 🎯 Calculating position for:`, {\n                draggedElement: draggedElement.id || draggedElement.dataset.blocId,\n                targetInfo,\n                strategy\n            });\n            \n            let result;\n            \n            switch (targetInfo.type) {\n                case 'insertion':\n                    result = this.calculateInsertionPosition(draggedElement, targetInfo, strategy);\n                    break;\n                    \n                case 'positioning':\n                    result = this.calculateRelativePosition(draggedElement, targetInfo, strategy);\n                    break;\n                    \n                case 'container':\n                    result = this.calculateContainerPosition(draggedElement, targetInfo, strategy);\n                    break;\n                    \n                default:\n                    result = this.calculateFallbackPosition(draggedElement, targetInfo);\n            }\n            \n            const calculationTime = performance.now() - startTime;\n            console.log(`[PositionCalculator] ⚡ Calculation completed in ${calculationTime.toFixed(2)}ms`);\n            \n            return {\n                ...result,\n                calculationTime,\n                strategy,\n                timestamp: Date.now()\n            };\n        }\n        \n        /**\n         * حساب موضع insertion (بين العناصر)\n         */\n        calculateInsertionPosition(draggedElement, targetInfo, strategy) {\n            const container = targetInfo.container || document.getElementById(targetInfo.parentId);\n            const index = targetInfo.index;\n            \n            if (!container) {\n                return this.createErrorResult('Container not found');\n            }\n            \n            // تحديد نوع التخطيط\n            const layoutType = this.detectLayoutType(container);\n            const containerRect = this.getMeasurements(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            console.log(`[PositionCalculator] 📋 Insertion calculation:`, {\n                layoutType,\n                index,\n                containerSize: `${containerRect.width}x${containerRect.height}`\n            });\n            \n            switch (layoutType) {\n                case LayoutType.FLEX_ROW:\n                    return this.calculateFlexRowInsertion(draggedElement, container, index, strategy);\n                    \n                case LayoutType.FLEX_COLUMN:\n                    return this.calculateFlexColumnInsertion(draggedElement, container, index, strategy);\n                    \n                case LayoutType.BLOCK:\n                    return this.calculateBlockInsertion(draggedElement, container, index, strategy);\n                    \n                default:\n                    return this.calculateGenericInsertion(draggedElement, container, index, strategy);\n            }\n        }\n        \n        /**\n         * حساب موضع relative (above/below/left/right)\n         */\n        calculateRelativePosition(draggedElement, targetInfo, strategy) {\n            const targetElement = targetInfo.targetElement || document.getElementById(targetInfo.targetElementId);\n            const direction = targetInfo.position;\n            \n            if (!targetElement) {\n                return this.createErrorResult('Target element not found');\n            }\n            \n            const targetParent = targetElement.parentElement;\n            const targetRect = this.getMeasurements(targetElement);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            console.log(`[PositionCalculator] 🎯 Relative positioning:`, {\n                direction,\n                targetSize: `${targetRect.width}x${targetRect.height}`,\n                draggedSize: `${draggedRect.width}x${draggedRect.height}`\n            });\n            \n            // تحديد الحاجة لإنشاء wrapper\n            const needsWrapper = this.determineWrapperRequirement(targetElement, direction);\n            \n            if (needsWrapper) {\n                return this.calculateWrapperCreation(draggedElement, targetElement, direction, strategy);\n            } else {\n                return this.calculateDirectRelativePosition(draggedElement, targetElement, direction, strategy);\n            }\n        }\n        \n        /**\n         * حساب موضع داخل container\n         */\n        calculateContainerPosition(draggedElement, targetInfo, strategy) {\n            const container = targetInfo.container || document.getElementById(targetInfo.parentId);\n            \n            if (!container) {\n                return this.createErrorResult('Container not found');\n            }\n            \n            const containerRect = this.getMeasurements(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            const children = this.getValidChildren(container);\n            \n            // تحديد أفضل موضع داخل Container\n            let optimalIndex;\n            \n            switch (strategy) {\n                case CalculationStrategy.VISUAL_BALANCE:\n                    optimalIndex = this.calculateVisualBalanceIndex(container, draggedElement, children);\n                    break;\n                    \n                case CalculationStrategy.MINIMIZE_MOVEMENT:\n                    optimalIndex = this.calculateMinMovementIndex(container, draggedElement, children);\n                    break;\n                    \n                default:\n                    optimalIndex = children.length; // في النهاية افتراضياً\n            }\n            \n            return {\n                type: 'container-insertion',\n                parentId: container.id || container.dataset.blocId,\n                index: optimalIndex,\n                layoutType: this.detectLayoutType(container),\n                metadata: {\n                    containerRect,\n                    draggedRect,\n                    childrenCount: children.length,\n                    strategy\n                }\n            };\n        }\n        \n        // ==================== LAYOUT-SPECIFIC CALCULATIONS ====================\n        \n        calculateFlexRowInsertion(draggedElement, container, index, strategy) {\n            const children = this.getValidChildren(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            // حساب المسافات والمحاذاة\n            const gap = this.getFlexGap(container);\n            const alignment = this.getFlexAlignment(container);\n            \n            let x, y;\n            \n            if (children.length === 0) {\n                // Container فارغ\n                x = this.settings.minSpacing;\n                y = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n            } else if (index === 0) {\n                // في البداية\n                const firstChild = children[0];\n                const firstRect = this.getMeasurements(firstChild);\n                x = firstRect.x - gap - draggedRect.width;\n                y = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n            } else if (index >= children.length) {\n                // في النهاية\n                const lastChild = children[children.length - 1];\n                const lastRect = this.getMeasurements(lastChild);\n                x = lastRect.x + lastRect.width + gap;\n                y = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n            } else {\n                // بين عنصرين\n                const prevChild = children[index - 1];\n                const nextChild = children[index];\n                const prevRect = this.getMeasurements(prevChild);\n                const nextRect = this.getMeasurements(nextChild);\n                \n                x = prevRect.x + prevRect.width + ((nextRect.x - prevRect.x - prevRect.width) / 2) - (draggedRect.width / 2);\n                y = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n            }\n            \n            return {\n                type: 'flex-row-insertion',\n                parentId: container.id || container.dataset.blocId,\n                index,\n                position: { x, y },\n                layoutHint: 'horizontal',\n                metadata: {\n                    gap,\n                    alignment,\n                    strategy\n                }\n            };\n        }\n        \n        calculateFlexColumnInsertion(draggedElement, container, index, strategy) {\n            const children = this.getValidChildren(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            const gap = this.getFlexGap(container);\n            const alignment = this.getFlexAlignment(container);\n            \n            let x, y;\n            \n            if (children.length === 0) {\n                x = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n                y = this.settings.minSpacing;\n            } else if (index === 0) {\n                const firstChild = children[0];\n                const firstRect = this.getMeasurements(firstChild);\n                x = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n                y = firstRect.y - gap - draggedRect.height;\n            } else if (index >= children.length) {\n                const lastChild = children[children.length - 1];\n                const lastRect = this.getMeasurements(lastChild);\n                x = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n                y = lastRect.y + lastRect.height + gap;\n            } else {\n                const prevChild = children[index - 1];\n                const nextChild = children[index];\n                const prevRect = this.getMeasurements(prevChild);\n                const nextRect = this.getMeasurements(nextChild);\n                \n                x = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n                y = prevRect.y + prevRect.height + ((nextRect.y - prevRect.y - prevRect.height) / 2) - (draggedRect.height / 2);\n            }\n            \n            return {\n                type: 'flex-column-insertion',\n                parentId: container.id || container.dataset.blocId,\n                index,\n                position: { x, y },\n                layoutHint: 'vertical',\n                metadata: {\n                    gap,\n                    alignment,\n                    strategy\n                }\n            };\n        }\n        \n        calculateBlockInsertion(draggedElement, container, index, strategy) {\n            const children = this.getValidChildren(container);\n            const containerRect = this.getMeasurements(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            let y;\n            \n            if (children.length === 0) {\n                y = this.settings.minSpacing;\n            } else if (index === 0) {\n                const firstChild = children[0];\n                const firstRect = this.getMeasurements(firstChild);\n                y = firstRect.y - this.settings.minSpacing - draggedRect.height;\n            } else if (index >= children.length) {\n                const lastChild = children[children.length - 1];\n                const lastRect = this.getMeasurements(lastChild);\n                y = lastRect.y + lastRect.height + this.settings.minSpacing;\n            } else {\n                const prevChild = children[index - 1];\n                const nextChild = children[index];\n                const prevRect = this.getMeasurements(prevChild);\n                const nextRect = this.getMeasurements(nextChild);\n                \n                y = prevRect.y + prevRect.height + ((nextRect.y - prevRect.y - prevRect.height) / 2) - (draggedRect.height / 2);\n            }\n            \n            return {\n                type: 'block-insertion',\n                parentId: container.id || container.dataset.blocId,\n                index,\n                position: {\n                    x: this.settings.minSpacing,\n                    y\n                },\n                layoutHint: 'block',\n                metadata: {\n                    containerWidth: containerRect.width,\n                    strategy\n                }\n            };\n        }\n        \n        // ==================== WRAPPER CREATION ====================\n        \n        calculateWrapperCreation(draggedElement, targetElement, direction, strategy) {\n            const targetParent = targetElement.parentElement;\n            const targetRect = this.getMeasurements(targetElement);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            // تحديد نوع Wrapper المطلوب\n            const wrapperType = this.determineWrapperType(direction);\n            const wrapperConfig = this.calculateWrapperConfig(targetElement, draggedElement, direction);\n            \n            console.log(`[PositionCalculator] 📦 Creating wrapper:`, {\n                wrapperType,\n                direction,\n                targetElement: targetElement.id\n            });\n            \n            return {\n                type: 'wrapper-creation',\n                wrapperType,\n                targetElementId: targetElement.id || targetElement.dataset.blocId,\n                parentId: targetParent ? (targetParent.id || targetParent.dataset.blocId) : null,\n                direction,\n                wrapperConfig,\n                elementOrder: this.calculateElementOrder(draggedElement, targetElement, direction),\n                metadata: {\n                    targetRect,\n                    draggedRect,\n                    strategy\n                }\n            };\n        }\n        \n        determineWrapperType(direction) {\n            switch (direction) {\n                case PositionDirection.LEFT:\n                case PositionDirection.RIGHT:\n                    return 'horizontal-flex';\n                    \n                case PositionDirection.ABOVE:\n                case PositionDirection.BELOW:\n                    return 'vertical-flex';\n                    \n                default:\n                    return 'generic-container';\n            }\n        }\n        \n        calculateWrapperConfig(targetElement, draggedElement, direction) {\n            const config = {\n                display: 'flex',\n                gap: this.settings.flexGapDefault + 'px'\n            };\n            \n            switch (direction) {\n                case PositionDirection.LEFT:\n                case PositionDirection.RIGHT:\n                    config.flexDirection = 'row';\n                    config.alignItems = 'center';\n                    break;\n                    \n                case PositionDirection.ABOVE:\n                case PositionDirection.BELOW:\n                    config.flexDirection = 'column';\n                    config.alignItems = 'stretch';\n                    break;\n            }\n            \n            return config;\n        }\n        \n        calculateElementOrder(draggedElement, targetElement, direction) {\n            switch (direction) {\n                case PositionDirection.LEFT:\n                case PositionDirection.ABOVE:\n                    return [draggedElement, targetElement];\n                    \n                case PositionDirection.RIGHT:\n                case PositionDirection.BELOW:\n                    return [targetElement, draggedElement];\n                    \n                default:\n                    return [targetElement, draggedElement];\n            }\n        }\n        \n        // ==================== MEASUREMENT & DETECTION ====================\n        \n        detectLayoutType(container) {\n            const cacheKey = `layout-${container.id || container.dataset.blocId}`;\n            \n            if (this.layoutCache.has(cacheKey)) {\n                return this.layoutCache.get(cacheKey);\n            }\n            \n            const computedStyle = window.getComputedStyle(container);\n            let layoutType;\n            \n            if (computedStyle.display === 'flex') {\n                const flexDirection = computedStyle.flexDirection;\n                layoutType = flexDirection === 'row' || flexDirection === 'row-reverse' \n                    ? LayoutType.FLEX_ROW \n                    : LayoutType.FLEX_COLUMN;\n            } else if (computedStyle.display === 'grid') {\n                layoutType = LayoutType.GRID;\n            } else if (computedStyle.position === 'absolute' || computedStyle.position === 'fixed') {\n                layoutType = LayoutType.ABSOLUTE;\n            } else {\n                layoutType = LayoutType.BLOCK;\n            }\n            \n            this.layoutCache.set(cacheKey, layoutType);\n            return layoutType;\n        }\n        \n        getMeasurements(element) {\n            const cacheKey = `measurements-${element.id || element.dataset.blocId || Date.now()}`;\n            \n            if (this.measurementCache.has(cacheKey)) {\n                return this.measurementCache.get(cacheKey);\n            }\n            \n            const rect = element.getBoundingClientRect();\n            const computedStyle = window.getComputedStyle(element);\n            \n            const measurements = {\n                x: rect.left,\n                y: rect.top,\n                width: rect.width,\n                height: rect.height,\n                top: rect.top,\n                right: rect.right,\n                bottom: rect.bottom,\n                left: rect.left,\n                marginTop: parseFloat(computedStyle.marginTop) || 0,\n                marginRight: parseFloat(computedStyle.marginRight) || 0,\n                marginBottom: parseFloat(computedStyle.marginBottom) || 0,\n                marginLeft: parseFloat(computedStyle.marginLeft) || 0,\n                paddingTop: parseFloat(computedStyle.paddingTop) || 0,\n                paddingRight: parseFloat(computedStyle.paddingRight) || 0,\n                paddingBottom: parseFloat(computedStyle.paddingBottom) || 0,\n                paddingLeft: parseFloat(computedStyle.paddingLeft) || 0\n            };\n            \n            this.measurementCache.set(cacheKey, measurements);\n            \n            // تنظيف Cache بعد فترة\n            setTimeout(() => {\n                this.measurementCache.delete(cacheKey);\n            }, this.cacheTimeout);\n            \n            return measurements;\n        }\n        \n        getFlexGap(flexContainer) {\n            const computedStyle = window.getComputedStyle(flexContainer);\n            const gap = computedStyle.gap || computedStyle.columnGap || computedStyle.rowGap;\n            \n            if (gap && gap !== 'normal') {\n                return parseFloat(gap) || this.settings.flexGapDefault;\n            }\n            \n            return this.settings.flexGapDefault;\n        }\n        \n        getFlexAlignment(flexContainer) {\n            const computedStyle = window.getComputedStyle(flexContainer);\n            \n            return {\n                justifyContent: computedStyle.justifyContent || 'flex-start',\n                alignItems: computedStyle.alignItems || 'stretch',\n                flexDirection: computedStyle.flexDirection || 'row'\n            };\n        }\n        \n        calculateFlexCrossAxisPosition(container, element, alignItems) {\n            const containerRect = this.getMeasurements(container);\n            const elementRect = this.getMeasurements(element);\n            \n            switch (alignItems) {\n                case 'flex-start':\n                case 'start':\n                    return containerRect.paddingTop;\n                    \n                case 'flex-end':\n                case 'end':\n                    return containerRect.height - containerRect.paddingBottom - elementRect.height;\n                    \n                case 'center':\n                    return (containerRect.height - elementRect.height) / 2;\n                    \n                case 'stretch':\n                default:\n                    return containerRect.paddingTop;\n            }\n        }\n        \n        getValidChildren(container) {\n            return Array.from(container.children).filter(child => \n                !child.classList.contains('bloc-insertion-indicator') &&\n                !child.classList.contains('bloc-positioning-indicator') &&\n                !child.classList.contains('bloc-drop-zone') &&\n                child.style.display !== 'none'\n            );\n        }\n        \n        // ==================== HELPER METHODS ====================\n        \n        determineWrapperRequirement(targetElement, direction) {\n            const parent = targetElement.parentElement;\n            if (!parent) return true;\n            \n            const parentLayoutType = this.detectLayoutType(parent);\n            \n            // إذا كان الـ parent flex و الاتجاه متوافق، لا نحتاج wrapper\n            if (parentLayoutType === LayoutType.FLEX_ROW && ['left', 'right'].includes(direction)) {\n                return false;\n            }\n            \n            if (parentLayoutType === LayoutType.FLEX_COLUMN && ['above', 'below'].includes(direction)) {\n                return false;\n            }\n            \n            return true;\n        }\n        \n        calculateDirectRelativePosition(draggedElement, targetElement, direction, strategy) {\n            const targetParent = targetElement.parentElement;\n            const targetIndex = Array.from(targetParent.children).indexOf(targetElement);\n            \n            let newIndex;\n            switch (direction) {\n                case PositionDirection.ABOVE:\n                case PositionDirection.LEFT:\n                    newIndex = targetIndex;\n                    break;\n                    \n                case PositionDirection.BELOW:\n                case PositionDirection.RIGHT:\n                    newIndex = targetIndex + 1;\n                    break;\n                    \n                default:\n                    newIndex = targetIndex + 1;\n            }\n            \n            return {\n                type: 'direct-relative',\n                parentId: targetParent.id || targetParent.dataset.blocId,\n                index: newIndex,\n                direction,\n                layoutHint: direction,\n                metadata: {\n                    targetElementId: targetElement.id || targetElement.dataset.blocId,\n                    strategy\n                }\n            };\n        }\n        \n        calculateVisualBalanceIndex(container, draggedElement, children) {\n            // حساب التوازن البصري (خوارزمية مبسطة)\n            if (children.length === 0) return 0;\n            \n            const draggedRect = this.getMeasurements(draggedElement);\n            let bestIndex = 0;\n            let bestScore = -1;\n            \n            for (let i = 0; i <= children.length; i++) {\n                const score = this.calculateVisualBalanceScore(container, children, draggedElement, i);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestIndex = i;\n                }\n            }\n            \n            return bestIndex;\n        }\n        \n        calculateVisualBalanceScore(container, children, draggedElement, insertIndex) {\n            // خوارزمية مبسطة لحساب التوازن البصري\n            const draggedRect = this.getMeasurements(draggedElement);\n            let score = 0;\n            \n            // عوامل مختلفة للتوازن\n            score += this.calculateSizeBalance(children, draggedElement, insertIndex);\n            score += this.calculateSpaceBalance(container, children, draggedElement, insertIndex);\n            score += this.calculateAlignmentScore(children, draggedElement, insertIndex);\n            \n            return score;\n        }\n        \n        calculateSizeBalance(children, draggedElement, insertIndex) {\n            // حساب توازن الأحجام\n            if (children.length === 0) return 100;\n            \n            const draggedRect = this.getMeasurements(draggedElement);\n            const draggedArea = draggedRect.width * draggedRect.height;\n            \n            let totalArea = draggedArea;\n            children.forEach(child => {\n                const rect = this.getMeasurements(child);\n                totalArea += rect.width * rect.height;\n            });\n            \n            const averageArea = totalArea / (children.length + 1);\n            const sizeRatio = Math.min(draggedArea / averageArea, averageArea / draggedArea);\n            \n            return sizeRatio * 50; // 0-50 points\n        }\n        \n        calculateSpaceBalance(container, children, draggedElement, insertIndex) {\n            // حساب توازن المساحات\n            const containerRect = this.getMeasurements(container);\n            // تنفيذ مبسط\n            return 25; // 0-25 points\n        }\n        \n        calculateAlignmentScore(children, draggedElement, insertIndex) {\n            // حساب نقاط المحاذاة\n            // تنفيذ مبسط\n            return 25; // 0-25 points\n        }\n        \n        calculateMinMovementIndex(container, draggedElement, children) {\n            // العثور على موضع يتطلب أقل حركة للعناصر الأخرى\n            return children.length; // في النهاية افتراضياً\n        }\n        \n        createErrorResult(message) {\n            return {\n                type: 'error',\n                error: message,\n                fallback: {\n                    type: 'append',\n                    parentId: 'canvas-container',\n                    index: -1\n                }\n            };\n        }\n        \n        calculateFallbackPosition(draggedElement, targetInfo) {\n            console.warn('[PositionCalculator] ⚠️ Using fallback position calculation');\n            \n            return {\n                type: 'fallback',\n                parentId: 'canvas-container',\n                index: -1,\n                position: { x: 10, y: 10 },\n                layoutHint: 'append'\n            };\n        }\n        \n        // ==================== CACHE MANAGEMENT ====================\n        \n        cleanupCache() {\n            const now = Date.now();\n            \n            // تنظيف Layout Cache\n            this.layoutCache.forEach((value, key) => {\n                if (typeof value === 'object' && value.timestamp && now - value.timestamp > this.cacheTimeout) {\n                    this.layoutCache.delete(key);\n                }\n            });\n            \n            // تنظيف Measurement Cache\n            this.measurementCache.forEach((value, key) => {\n                if (value.timestamp && now - value.timestamp > this.cacheTimeout) {\n                    this.measurementCache.delete(key);\n                }\n            });\n        }\n        \n        invalidateCache(elementId = null) {\n            if (elementId) {\n                // إزالة cache للعنصر المحدد\n                this.layoutCache.delete(`layout-${elementId}`);\n                this.measurementCache.delete(`measurements-${elementId}`);\n            } else {\n                // مسح جميع Cache\n                this.layoutCache.clear();\n                this.measurementCache.clear();\n            }\n        }\n        \n        // ==================== PUBLIC API ====================\n        \n        updateSettings(newSettings) {\n            this.settings = { ...this.settings, ...newSettings };\n            console.log('[PositionCalculator] ⚙️ Settings updated:', this.settings);\n        }\n        \n        getPerformanceInfo() {\n            return {\n                layoutCacheSize: this.layoutCache.size,\n                measurementCacheSize: this.measurementCache.size,\n                settings: this.settings\n            };\n        }\n        \n        // Debug methods\n        debugShowCalculation(draggedElement, targetInfo) {\n            console.group('[PositionCalculator] 🐛 Debug Calculation');\n            const result = this.calculateOptimalPosition(draggedElement, targetInfo, CalculationStrategy.OPTIMAL);\n            console.log('Input:', { draggedElement, targetInfo });\n            console.log('Result:', result);\n            console.groupEnd();\n            return result;\n        }\n    }\n    \n    // ==================== GLOBAL EXPORT ====================\n    \n    // إنشاء instance عام\n    window.BlocVibePositionCalculator = new PositionCalculator();\n    \n    // تصدير الأنواع للاستخدام في ملفات أخرى\n    window.BlocVibeLayoutType = LayoutType;\n    window.BlocVibePositionDirection = PositionDirection;\n    window.BlocVibeCalculationStrategy = CalculationStrategy;\n    \n    console.log('[PositionCalculator] 🌟 PositionCalculator loaded and ready!');\n    \n})();