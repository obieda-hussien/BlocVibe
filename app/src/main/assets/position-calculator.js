/**
 * BlocVibe PositionCalculator v3.0
 * ==================================
 * Ù†Ø¸Ø§Ù… Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ø°ÙƒÙŠØ© Ù„Ù„Ø¹Ù†Ø§ØµØ±
 * ÙŠØ­Ø³Ø¨ Ø£ÙØ¶Ù„ Ù…ÙˆØ§Ø¶Ø¹ Ù„Ù„Ø¹Ù†Ø§ØµØ± Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© FlexboxØŒ Ø§Ù„ØªØ®Ø·ÙŠØ·ØŒ ÙˆØ§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ù…ÙƒØ§Ù†ÙŠØ©
 * 
 * Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:
 * - Ø­Ø³Ø§Ø¨ Ù…ÙˆØ§Ø¶Ø¹ relative Ù„Ù„Ø¹Ù†Ø§ØµØ±
 * - Ø¥Ø¯Ø§Ø±Ø© Flexbox layouts
 * - Ø­Ø³Ø§Ø¨ insertion points Ø°ÙƒÙŠØ©
 * - ØªØ­Ø³ÙŠÙ† ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù†Ø§ØµØ±
 * - Ø¯Ø¹Ù… responsive positioning
 */

(function() {
    'use strict';
    
    // ==================== ENUMS & CONSTANTS ====================
    
    /**
     * Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØªØ®Ø·ÙŠØ· Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©
     */
    const LayoutType = Object.freeze({
        BLOCK: 'block',           // ØªØ®Ø·ÙŠØ· block Ø¹Ø§Ø¯ÙŠ
        FLEX_ROW: 'flex-row',     // flexbox horizontal
        FLEX_COLUMN: 'flex-column', // flexbox vertical
        GRID: 'grid',             // CSS Grid (Ù„Ù„Ù…Ø³ØªÙ‚Ø¨Ù„)
        ABSOLUTE: 'absolute'      // Ù…ÙˆØ¶Ø¹ Ù…Ø·Ù„Ù‚
    });
    
    /**
     * Ø§ØªØ¬Ø§Ù‡Ø§Øª Positioning
     */
    const PositionDirection = Object.freeze({
        ABOVE: 'above',
        BELOW: 'below',
        LEFT: 'left',
        RIGHT: 'right',
        INSIDE: 'inside',
        REPLACE: 'replace'
    });
    
    /**
     * Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø­Ø³Ø§Ø¨
     */
    const CalculationStrategy = Object.freeze({
        OPTIMAL: 'optimal',         // Ø£ÙØ¶Ù„ Ù…ÙˆØ¶Ø¹ Ù…Ù…ÙƒÙ†
        PRESERVE_LAYOUT: 'preserve-layout', // Ø­ÙØ¸ Ø§Ù„ØªØ®Ø·ÙŠØ· Ø§Ù„Ø­Ø§Ù„ÙŠ
        MINIMIZE_MOVEMENT: 'minimize-movement', // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ø±ÙƒØ©
        VISUAL_BALANCE: 'visual-balance' // ØªÙˆØ§Ø²Ù† Ø¨ØµØ±ÙŠ
    });
    
    // ==================== CLASS DEFINITION ====================
    
    class PositionCalculator {
        constructor() {\n            this.layoutCache = new Map();        // Cache Ù„Ù„ØªØ®Ø·ÙŠØ·Ø§Øª\n            this.measurementCache = new Map();   // Cache Ù„Ù„Ù‚ÙŠØ§Ø³Ø§Øª\n            this.cacheTimeout = 5000;            // 5 Ø«ÙˆØ§Ù†Ù\n            \n            // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨\n            this.settings = {\n                minSpacing: 8,                    // Ø£Ù‚Ù„ Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù†Ø§ØµØ±\n                snapThreshold: 15,                // Ø¹ØªØ¨Ø© Ø§Ù„Ù…Ø­Ø§Ø°Ø§Ø©\n                flexGapDefault: 10,               // Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© ÙÙŠ flex\n                considerVisualWeight: true,       // Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„ÙˆØ²Ù† Ø§Ù„Ø¨ØµØ±ÙŠ\n                respectAspectRatio: true          // Ø§Ø­ØªØ±Ø§Ù… Ù†Ø³Ø¨Ø© Ø§Ù„Ø¹Ø±Ø¶ Ù„Ù„Ø§Ø±ØªÙØ§Ø¹\n            };\n            \n            this.init();\n        }\n        \n        // ==================== INITIALIZATION ====================\n        \n        init() {\n            console.log('[PositionCalculator] ğŸ“ Initializing Position Calculation System...');\n            this.setupPerformanceOptimizations();\n            console.log('[PositionCalculator] âœ… Position calculator ready');\n        }\n        \n        setupPerformanceOptimizations() {\n            // ØªÙ†Ø¸ÙŠÙ Cache Ø¯ÙˆØ±ÙŠØ§Ù‹\n            setInterval(() => {\n                this.cleanupCache();\n            }, this.cacheTimeout);\n            \n            // Intersection Observer Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø±Ø¦ÙŠØ©\n            this.visibilityObserver = new IntersectionObserver((entries) => {\n                entries.forEach(entry => {\n                    const elementId = entry.target.id || entry.target.dataset.blocId;\n                    if (elementId) {\n                        this.layoutCache.set(`visibility-${elementId}`, entry.isIntersecting);\n                    }\n                });\n            });\n        }\n        \n        // ==================== CORE CALCULATION METHODS ====================\n        \n        /**\n         * Ø­Ø³Ø§Ø¨ Ø£ÙØ¶Ù„ Ù…ÙˆØ¶Ø¹ Ù„Ø¹Ù†ØµØ± Ù…Ø³Ø­ÙˆØ¨\n         */\n        calculateOptimalPosition(draggedElement, targetInfo, strategy = CalculationStrategy.OPTIMAL) {\n            const startTime = performance.now();\n            \n            console.log(`[PositionCalculator] ğŸ¯ Calculating position for:`, {\n                draggedElement: draggedElement.id || draggedElement.dataset.blocId,\n                targetInfo,\n                strategy\n            });\n            \n            let result;\n            \n            switch (targetInfo.type) {\n                case 'insertion':\n                    result = this.calculateInsertionPosition(draggedElement, targetInfo, strategy);\n                    break;\n                    \n                case 'positioning':\n                    result = this.calculateRelativePosition(draggedElement, targetInfo, strategy);\n                    break;\n                    \n                case 'container':\n                    result = this.calculateContainerPosition(draggedElement, targetInfo, strategy);\n                    break;\n                    \n                default:\n                    result = this.calculateFallbackPosition(draggedElement, targetInfo);\n            }\n            \n            const calculationTime = performance.now() - startTime;\n            console.log(`[PositionCalculator] âš¡ Calculation completed in ${calculationTime.toFixed(2)}ms`);\n            \n            return {\n                ...result,\n                calculationTime,\n                strategy,\n                timestamp: Date.now()\n            };\n        }\n        \n        /**\n         * Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ insertion (Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù†Ø§ØµØ±)\n         */\n        calculateInsertionPosition(draggedElement, targetInfo, strategy) {\n            const container = targetInfo.container || document.getElementById(targetInfo.parentId);\n            const index = targetInfo.index;\n            \n            if (!container) {\n                return this.createErrorResult('Container not found');\n            }\n            \n            // ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„ØªØ®Ø·ÙŠØ·\n            const layoutType = this.detectLayoutType(container);\n            const containerRect = this.getMeasurements(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            console.log(`[PositionCalculator] ğŸ“‹ Insertion calculation:`, {\n                layoutType,\n                index,\n                containerSize: `${containerRect.width}x${containerRect.height}`\n            });\n            \n            switch (layoutType) {\n                case LayoutType.FLEX_ROW:\n                    return this.calculateFlexRowInsertion(draggedElement, container, index, strategy);\n                    \n                case LayoutType.FLEX_COLUMN:\n                    return this.calculateFlexColumnInsertion(draggedElement, container, index, strategy);\n                    \n                case LayoutType.BLOCK:\n                    return this.calculateBlockInsertion(draggedElement, container, index, strategy);\n                    \n                default:\n                    return this.calculateGenericInsertion(draggedElement, container, index, strategy);\n            }\n        }\n        \n        /**\n         * Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ relative (above/below/left/right)\n         */\n        calculateRelativePosition(draggedElement, targetInfo, strategy) {\n            const targetElement = targetInfo.targetElement || document.getElementById(targetInfo.targetElementId);\n            const direction = targetInfo.position;\n            \n            if (!targetElement) {\n                return this.createErrorResult('Target element not found');\n            }\n            \n            const targetParent = targetElement.parentElement;\n            const targetRect = this.getMeasurements(targetElement);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            console.log(`[PositionCalculator] ğŸ¯ Relative positioning:`, {\n                direction,\n                targetSize: `${targetRect.width}x${targetRect.height}`,\n                draggedSize: `${draggedRect.width}x${draggedRect.height}`\n            });\n            \n            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ wrapper\n            const needsWrapper = this.determineWrapperRequirement(targetElement, direction);\n            \n            if (needsWrapper) {\n                return this.calculateWrapperCreation(draggedElement, targetElement, direction, strategy);\n            } else {\n                return this.calculateDirectRelativePosition(draggedElement, targetElement, direction, strategy);\n            }\n        }\n        \n        /**\n         * Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ Ø¯Ø§Ø®Ù„ container\n         */\n        calculateContainerPosition(draggedElement, targetInfo, strategy) {\n            const container = targetInfo.container || document.getElementById(targetInfo.parentId);\n            \n            if (!container) {\n                return this.createErrorResult('Container not found');\n            }\n            \n            const containerRect = this.getMeasurements(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            const children = this.getValidChildren(container);\n            \n            // ØªØ­Ø¯ÙŠØ¯ Ø£ÙØ¶Ù„ Ù…ÙˆØ¶Ø¹ Ø¯Ø§Ø®Ù„ Container\n            let optimalIndex;\n            \n            switch (strategy) {\n                case CalculationStrategy.VISUAL_BALANCE:\n                    optimalIndex = this.calculateVisualBalanceIndex(container, draggedElement, children);\n                    break;\n                    \n                case CalculationStrategy.MINIMIZE_MOVEMENT:\n                    optimalIndex = this.calculateMinMovementIndex(container, draggedElement, children);\n                    break;\n                    \n                default:\n                    optimalIndex = children.length; // ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹\n            }\n            \n            return {\n                type: 'container-insertion',\n                parentId: container.id || container.dataset.blocId,\n                index: optimalIndex,\n                layoutType: this.detectLayoutType(container),\n                metadata: {\n                    containerRect,\n                    draggedRect,\n                    childrenCount: children.length,\n                    strategy\n                }\n            };\n        }\n        \n        // ==================== LAYOUT-SPECIFIC CALCULATIONS ====================\n        \n        calculateFlexRowInsertion(draggedElement, container, index, strategy) {\n            const children = this.getValidChildren(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ§Øª ÙˆØ§Ù„Ù…Ø­Ø§Ø°Ø§Ø©\n            const gap = this.getFlexGap(container);\n            const alignment = this.getFlexAlignment(container);\n            \n            let x, y;\n            \n            if (children.length === 0) {\n                // Container ÙØ§Ø±Øº\n                x = this.settings.minSpacing;\n                y = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n            } else if (index === 0) {\n                // ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©\n                const firstChild = children[0];\n                const firstRect = this.getMeasurements(firstChild);\n                x = firstRect.x - gap - draggedRect.width;\n                y = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n            } else if (index >= children.length) {\n                // ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©\n                const lastChild = children[children.length - 1];\n                const lastRect = this.getMeasurements(lastChild);\n                x = lastRect.x + lastRect.width + gap;\n                y = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n            } else {\n                // Ø¨ÙŠÙ† Ø¹Ù†ØµØ±ÙŠÙ†\n                const prevChild = children[index - 1];\n                const nextChild = children[index];\n                const prevRect = this.getMeasurements(prevChild);\n                const nextRect = this.getMeasurements(nextChild);\n                \n                x = prevRect.x + prevRect.width + ((nextRect.x - prevRect.x - prevRect.width) / 2) - (draggedRect.width / 2);\n                y = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n            }\n            \n            return {\n                type: 'flex-row-insertion',\n                parentId: container.id || container.dataset.blocId,\n                index,\n                position: { x, y },\n                layoutHint: 'horizontal',\n                metadata: {\n                    gap,\n                    alignment,\n                    strategy\n                }\n            };\n        }\n        \n        calculateFlexColumnInsertion(draggedElement, container, index, strategy) {\n            const children = this.getValidChildren(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            const gap = this.getFlexGap(container);\n            const alignment = this.getFlexAlignment(container);\n            \n            let x, y;\n            \n            if (children.length === 0) {\n                x = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n                y = this.settings.minSpacing;\n            } else if (index === 0) {\n                const firstChild = children[0];\n                const firstRect = this.getMeasurements(firstChild);\n                x = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n                y = firstRect.y - gap - draggedRect.height;\n            } else if (index >= children.length) {\n                const lastChild = children[children.length - 1];\n                const lastRect = this.getMeasurements(lastChild);\n                x = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n                y = lastRect.y + lastRect.height + gap;\n            } else {\n                const prevChild = children[index - 1];\n                const nextChild = children[index];\n                const prevRect = this.getMeasurements(prevChild);\n                const nextRect = this.getMeasurements(nextChild);\n                \n                x = this.calculateFlexCrossAxisPosition(container, draggedElement, alignment.alignItems);\n                y = prevRect.y + prevRect.height + ((nextRect.y - prevRect.y - prevRect.height) / 2) - (draggedRect.height / 2);\n            }\n            \n            return {\n                type: 'flex-column-insertion',\n                parentId: container.id || container.dataset.blocId,\n                index,\n                position: { x, y },\n                layoutHint: 'vertical',\n                metadata: {\n                    gap,\n                    alignment,\n                    strategy\n                }\n            };\n        }\n        \n        calculateBlockInsertion(draggedElement, container, index, strategy) {\n            const children = this.getValidChildren(container);\n            const containerRect = this.getMeasurements(container);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            let y;\n            \n            if (children.length === 0) {\n                y = this.settings.minSpacing;\n            } else if (index === 0) {\n                const firstChild = children[0];\n                const firstRect = this.getMeasurements(firstChild);\n                y = firstRect.y - this.settings.minSpacing - draggedRect.height;\n            } else if (index >= children.length) {\n                const lastChild = children[children.length - 1];\n                const lastRect = this.getMeasurements(lastChild);\n                y = lastRect.y + lastRect.height + this.settings.minSpacing;\n            } else {\n                const prevChild = children[index - 1];\n                const nextChild = children[index];\n                const prevRect = this.getMeasurements(prevChild);\n                const nextRect = this.getMeasurements(nextChild);\n                \n                y = prevRect.y + prevRect.height + ((nextRect.y - prevRect.y - prevRect.height) / 2) - (draggedRect.height / 2);\n            }\n            \n            return {\n                type: 'block-insertion',\n                parentId: container.id || container.dataset.blocId,\n                index,\n                position: {\n                    x: this.settings.minSpacing,\n                    y\n                },\n                layoutHint: 'block',\n                metadata: {\n                    containerWidth: containerRect.width,\n                    strategy\n                }\n            };\n        }\n        \n        // ==================== WRAPPER CREATION ====================\n        \n        calculateWrapperCreation(draggedElement, targetElement, direction, strategy) {\n            const targetParent = targetElement.parentElement;\n            const targetRect = this.getMeasurements(targetElement);\n            const draggedRect = this.getMeasurements(draggedElement);\n            \n            // ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Wrapper Ø§Ù„Ù…Ø·Ù„ÙˆØ¨\n            const wrapperType = this.determineWrapperType(direction);\n            const wrapperConfig = this.calculateWrapperConfig(targetElement, draggedElement, direction);\n            \n            console.log(`[PositionCalculator] ğŸ“¦ Creating wrapper:`, {\n                wrapperType,\n                direction,\n                targetElement: targetElement.id\n            });\n            \n            return {\n                type: 'wrapper-creation',\n                wrapperType,\n                targetElementId: targetElement.id || targetElement.dataset.blocId,\n                parentId: targetParent ? (targetParent.id || targetParent.dataset.blocId) : null,\n                direction,\n                wrapperConfig,\n                elementOrder: this.calculateElementOrder(draggedElement, targetElement, direction),\n                metadata: {\n                    targetRect,\n                    draggedRect,\n                    strategy\n                }\n            };\n        }\n        \n        determineWrapperType(direction) {\n            switch (direction) {\n                case PositionDirection.LEFT:\n                case PositionDirection.RIGHT:\n                    return 'horizontal-flex';\n                    \n                case PositionDirection.ABOVE:\n                case PositionDirection.BELOW:\n                    return 'vertical-flex';\n                    \n                default:\n                    return 'generic-container';\n            }\n        }\n        \n        calculateWrapperConfig(targetElement, draggedElement, direction) {\n            const config = {\n                display: 'flex',\n                gap: this.settings.flexGapDefault + 'px'\n            };\n            \n            switch (direction) {\n                case PositionDirection.LEFT:\n                case PositionDirection.RIGHT:\n                    config.flexDirection = 'row';\n                    config.alignItems = 'center';\n                    break;\n                    \n                case PositionDirection.ABOVE:\n                case PositionDirection.BELOW:\n                    config.flexDirection = 'column';\n                    config.alignItems = 'stretch';\n                    break;\n            }\n            \n            return config;\n        }\n        \n        calculateElementOrder(draggedElement, targetElement, direction) {\n            switch (direction) {\n                case PositionDirection.LEFT:\n                case PositionDirection.ABOVE:\n                    return [draggedElement, targetElement];\n                    \n                case PositionDirection.RIGHT:\n                case PositionDirection.BELOW:\n                    return [targetElement, draggedElement];\n                    \n                default:\n                    return [targetElement, draggedElement];\n            }\n        }\n        \n        // ==================== MEASUREMENT & DETECTION ====================\n        \n        detectLayoutType(container) {\n            const cacheKey = `layout-${container.id || container.dataset.blocId}`;\n            \n            if (this.layoutCache.has(cacheKey)) {\n                return this.layoutCache.get(cacheKey);\n            }\n            \n            const computedStyle = window.getComputedStyle(container);\n            let layoutType;\n            \n            if (computedStyle.display === 'flex') {\n                const flexDirection = computedStyle.flexDirection;\n                layoutType = flexDirection === 'row' || flexDirection === 'row-reverse' \n                    ? LayoutType.FLEX_ROW \n                    : LayoutType.FLEX_COLUMN;\n            } else if (computedStyle.display === 'grid') {\n                layoutType = LayoutType.GRID;\n            } else if (computedStyle.position === 'absolute' || computedStyle.position === 'fixed') {\n                layoutType = LayoutType.ABSOLUTE;\n            } else {\n                layoutType = LayoutType.BLOCK;\n            }\n            \n            this.layoutCache.set(cacheKey, layoutType);\n            return layoutType;\n        }\n        \n        getMeasurements(element) {\n            const cacheKey = `measurements-${element.id || element.dataset.blocId || Date.now()}`;\n            \n            if (this.measurementCache.has(cacheKey)) {\n                return this.measurementCache.get(cacheKey);\n            }\n            \n            const rect = element.getBoundingClientRect();\n            const computedStyle = window.getComputedStyle(element);\n            \n            const measurements = {\n                x: rect.left,\n                y: rect.top,\n                width: rect.width,\n                height: rect.height,\n                top: rect.top,\n                right: rect.right,\n                bottom: rect.bottom,\n                left: rect.left,\n                marginTop: parseFloat(computedStyle.marginTop) || 0,\n                marginRight: parseFloat(computedStyle.marginRight) || 0,\n                marginBottom: parseFloat(computedStyle.marginBottom) || 0,\n                marginLeft: parseFloat(computedStyle.marginLeft) || 0,\n                paddingTop: parseFloat(computedStyle.paddingTop) || 0,\n                paddingRight: parseFloat(computedStyle.paddingRight) || 0,\n                paddingBottom: parseFloat(computedStyle.paddingBottom) || 0,\n                paddingLeft: parseFloat(computedStyle.paddingLeft) || 0\n            };\n            \n            this.measurementCache.set(cacheKey, measurements);\n            \n            // ØªÙ†Ø¸ÙŠÙ Cache Ø¨Ø¹Ø¯ ÙØªØ±Ø©\n            setTimeout(() => {\n                this.measurementCache.delete(cacheKey);\n            }, this.cacheTimeout);\n            \n            return measurements;\n        }\n        \n        getFlexGap(flexContainer) {\n            const computedStyle = window.getComputedStyle(flexContainer);\n            const gap = computedStyle.gap || computedStyle.columnGap || computedStyle.rowGap;\n            \n            if (gap && gap !== 'normal') {\n                return parseFloat(gap) || this.settings.flexGapDefault;\n            }\n            \n            return this.settings.flexGapDefault;\n        }\n        \n        getFlexAlignment(flexContainer) {\n            const computedStyle = window.getComputedStyle(flexContainer);\n            \n            return {\n                justifyContent: computedStyle.justifyContent || 'flex-start',\n                alignItems: computedStyle.alignItems || 'stretch',\n                flexDirection: computedStyle.flexDirection || 'row'\n            };\n        }\n        \n        calculateFlexCrossAxisPosition(container, element, alignItems) {\n            const containerRect = this.getMeasurements(container);\n            const elementRect = this.getMeasurements(element);\n            \n            switch (alignItems) {\n                case 'flex-start':\n                case 'start':\n                    return containerRect.paddingTop;\n                    \n                case 'flex-end':\n                case 'end':\n                    return containerRect.height - containerRect.paddingBottom - elementRect.height;\n                    \n                case 'center':\n                    return (containerRect.height - elementRect.height) / 2;\n                    \n                case 'stretch':\n                default:\n                    return containerRect.paddingTop;\n            }\n        }\n        \n        getValidChildren(container) {\n            return Array.from(container.children).filter(child => \n                !child.classList.contains('bloc-insertion-indicator') &&\n                !child.classList.contains('bloc-positioning-indicator') &&\n                !child.classList.contains('bloc-drop-zone') &&\n                child.style.display !== 'none'\n            );\n        }\n        \n        // ==================== HELPER METHODS ====================\n        \n        determineWrapperRequirement(targetElement, direction) {\n            const parent = targetElement.parentElement;\n            if (!parent) return true;\n            \n            const parentLayoutType = this.detectLayoutType(parent);\n            \n            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù€ parent flex Ùˆ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ù…ØªÙˆØ§ÙÙ‚ØŒ Ù„Ø§ Ù†Ø­ØªØ§Ø¬ wrapper\n            if (parentLayoutType === LayoutType.FLEX_ROW && ['left', 'right'].includes(direction)) {\n                return false;\n            }\n            \n            if (parentLayoutType === LayoutType.FLEX_COLUMN && ['above', 'below'].includes(direction)) {\n                return false;\n            }\n            \n            return true;\n        }\n        \n        calculateDirectRelativePosition(draggedElement, targetElement, direction, strategy) {\n            const targetParent = targetElement.parentElement;\n            const targetIndex = Array.from(targetParent.children).indexOf(targetElement);\n            \n            let newIndex;\n            switch (direction) {\n                case PositionDirection.ABOVE:\n                case PositionDirection.LEFT:\n                    newIndex = targetIndex;\n                    break;\n                    \n                case PositionDirection.BELOW:\n                case PositionDirection.RIGHT:\n                    newIndex = targetIndex + 1;\n                    break;\n                    \n                default:\n                    newIndex = targetIndex + 1;\n            }\n            \n            return {\n                type: 'direct-relative',\n                parentId: targetParent.id || targetParent.dataset.blocId,\n                index: newIndex,\n                direction,\n                layoutHint: direction,\n                metadata: {\n                    targetElementId: targetElement.id || targetElement.dataset.blocId,\n                    strategy\n                }\n            };\n        }\n        \n        calculateVisualBalanceIndex(container, draggedElement, children) {\n            // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙˆØ§Ø²Ù† Ø§Ù„Ø¨ØµØ±ÙŠ (Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ù…Ø¨Ø³Ø·Ø©)\n            if (children.length === 0) return 0;\n            \n            const draggedRect = this.getMeasurements(draggedElement);\n            let bestIndex = 0;\n            let bestScore = -1;\n            \n            for (let i = 0; i <= children.length; i++) {\n                const score = this.calculateVisualBalanceScore(container, children, draggedElement, i);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestIndex = i;\n                }\n            }\n            \n            return bestIndex;\n        }\n        \n        calculateVisualBalanceScore(container, children, draggedElement, insertIndex) {\n            // Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ù…Ø¨Ø³Ø·Ø© Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙˆØ§Ø²Ù† Ø§Ù„Ø¨ØµØ±ÙŠ\n            const draggedRect = this.getMeasurements(draggedElement);\n            let score = 0;\n            \n            // Ø¹ÙˆØ§Ù…Ù„ Ù…Ø®ØªÙ„ÙØ© Ù„Ù„ØªÙˆØ§Ø²Ù†\n            score += this.calculateSizeBalance(children, draggedElement, insertIndex);\n            score += this.calculateSpaceBalance(container, children, draggedElement, insertIndex);\n            score += this.calculateAlignmentScore(children, draggedElement, insertIndex);\n            \n            return score;\n        }\n        \n        calculateSizeBalance(children, draggedElement, insertIndex) {\n            // Ø­Ø³Ø§Ø¨ ØªÙˆØ§Ø²Ù† Ø§Ù„Ø£Ø­Ø¬Ø§Ù…\n            if (children.length === 0) return 100;\n            \n            const draggedRect = this.getMeasurements(draggedElement);\n            const draggedArea = draggedRect.width * draggedRect.height;\n            \n            let totalArea = draggedArea;\n            children.forEach(child => {\n                const rect = this.getMeasurements(child);\n                totalArea += rect.width * rect.height;\n            });\n            \n            const averageArea = totalArea / (children.length + 1);\n            const sizeRatio = Math.min(draggedArea / averageArea, averageArea / draggedArea);\n            \n            return sizeRatio * 50; // 0-50 points\n        }\n        \n        calculateSpaceBalance(container, children, draggedElement, insertIndex) {\n            // Ø­Ø³Ø§Ø¨ ØªÙˆØ§Ø²Ù† Ø§Ù„Ù…Ø³Ø§Ø­Ø§Øª\n            const containerRect = this.getMeasurements(container);\n            // ØªÙ†ÙÙŠØ° Ù…Ø¨Ø³Ø·\n            return 25; // 0-25 points\n        }\n        \n        calculateAlignmentScore(children, draggedElement, insertIndex) {\n            // Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø­Ø§Ø°Ø§Ø©\n            // ØªÙ†ÙÙŠØ° Ù…Ø¨Ø³Ø·\n            return 25; // 0-25 points\n        }\n        \n        calculateMinMovementIndex(container, draggedElement, children) {\n            // Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…ÙˆØ¶Ø¹ ÙŠØªØ·Ù„Ø¨ Ø£Ù‚Ù„ Ø­Ø±ÙƒØ© Ù„Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø£Ø®Ø±Ù‰\n            return children.length; // ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹\n        }\n        \n        createErrorResult(message) {\n            return {\n                type: 'error',\n                error: message,\n                fallback: {\n                    type: 'append',\n                    parentId: 'canvas-container',\n                    index: -1\n                }\n            };\n        }\n        \n        calculateFallbackPosition(draggedElement, targetInfo) {\n            console.warn('[PositionCalculator] âš ï¸ Using fallback position calculation');\n            \n            return {\n                type: 'fallback',\n                parentId: 'canvas-container',\n                index: -1,\n                position: { x: 10, y: 10 },\n                layoutHint: 'append'\n            };\n        }\n        \n        // ==================== CACHE MANAGEMENT ====================\n        \n        cleanupCache() {\n            const now = Date.now();\n            \n            // ØªÙ†Ø¸ÙŠÙ Layout Cache\n            this.layoutCache.forEach((value, key) => {\n                if (typeof value === 'object' && value.timestamp && now - value.timestamp > this.cacheTimeout) {\n                    this.layoutCache.delete(key);\n                }\n            });\n            \n            // ØªÙ†Ø¸ÙŠÙ Measurement Cache\n            this.measurementCache.forEach((value, key) => {\n                if (value.timestamp && now - value.timestamp > this.cacheTimeout) {\n                    this.measurementCache.delete(key);\n                }\n            });\n        }\n        \n        invalidateCache(elementId = null) {\n            if (elementId) {\n                // Ø¥Ø²Ø§Ù„Ø© cache Ù„Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø­Ø¯Ø¯\n                this.layoutCache.delete(`layout-${elementId}`);\n                this.measurementCache.delete(`measurements-${elementId}`);\n            } else {\n                // Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Cache\n                this.layoutCache.clear();\n                this.measurementCache.clear();\n            }\n        }\n        \n        // ==================== PUBLIC API ====================\n        \n        updateSettings(newSettings) {\n            this.settings = { ...this.settings, ...newSettings };\n            console.log('[PositionCalculator] âš™ï¸ Settings updated:', this.settings);\n        }\n        \n        getPerformanceInfo() {\n            return {\n                layoutCacheSize: this.layoutCache.size,\n                measurementCacheSize: this.measurementCache.size,\n                settings: this.settings\n            };\n        }\n        \n        // Debug methods\n        debugShowCalculation(draggedElement, targetInfo) {\n            console.group('[PositionCalculator] ğŸ› Debug Calculation');\n            const result = this.calculateOptimalPosition(draggedElement, targetInfo, CalculationStrategy.OPTIMAL);\n            console.log('Input:', { draggedElement, targetInfo });\n            console.log('Result:', result);\n            console.groupEnd();\n            return result;\n        }\n    }\n    \n    // ==================== GLOBAL EXPORT ====================\n    \n    // Ø¥Ù†Ø´Ø§Ø¡ instance Ø¹Ø§Ù…\n    window.BlocVibePositionCalculator = new PositionCalculator();\n    \n    // ØªØµØ¯ÙŠØ± Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ Ù…Ù„ÙØ§Øª Ø£Ø®Ø±Ù‰\n    window.BlocVibeLayoutType = LayoutType;\n    window.BlocVibePositionDirection = PositionDirection;\n    window.BlocVibeCalculationStrategy = CalculationStrategy;\n    \n    console.log('[PositionCalculator] ğŸŒŸ PositionCalculator loaded and ready!');\n    \n})();